import JSZip from 'jszip';
import { saveAs } from 'file-saver';

// Download a single PRD as markdown
export function downloadPRD(feature: any) {
  // Format user stories - handle both string and object formats
  const formatUserStory = (story: any, i: number) => {
    if (typeof story === 'string') {
      return `${i + 1}. ${story}`;
    }
    if (story.persona && story.need && story.goal) {
      return `${i + 1}. As a ${story.persona}, I want to ${story.need} so that ${story.goal}`;
    }
    return `${i + 1}. ${JSON.stringify(story)}`;
  };

  const userStoriesText = feature.userStories?.length > 0
    ? feature.userStories.map(formatUserStory).join('\n')
    : 'No user stories defined';

  const content = `# ${feature.title}

## Description
${feature.description || 'No description provided'}

## User Stories
${userStoriesText}

## Acceptance Criteria
${feature.acceptanceCriteria?.map((criteria: string, i: number) => `- ${criteria}`).join('\n') || 'No acceptance criteria defined'}

## Technical Implementation
${typeof feature.technicalImplementation === 'string' 
  ? feature.technicalImplementation 
  : feature.technicalImplementation 
    ? JSON.stringify(feature.technicalImplementation, null, 2)
    : 'No technical details provided'}

## API Endpoints
${feature.apiEndpoints?.map((ep: any) => `- ${ep.method} ${ep.path} - ${ep.description}`).join('\n') || 'No API endpoints defined'}

## Dependencies
${feature.dependencies?.map((dep: string) => `- ${dep}`).join('\n') || 'No dependencies'}

## Edge Cases
${feature.edgeCases?.map((edge: string) => `- ${edge}`).join('\n') || 'No edge cases defined'}

---
Generated by CodeLaunch
`;

  const blob = new Blob([content], { type: 'text/markdown' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${feature.title.toLowerCase().replace(/\s+/g, '-')}-prd.md`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// Copy PRD to clipboard
export async function copyPRDToClipboard(feature: any) {
  // Format user stories - handle both string and object formats
  const formatUserStory = (story: any, i: number) => {
    if (typeof story === 'string') {
      return `${i + 1}. ${story}`;
    }
    if (story.persona && story.need && story.goal) {
      return `${i + 1}. As a ${story.persona}, I want to ${story.need} so that ${story.goal}`;
    }
    return `${i + 1}. ${JSON.stringify(story)}`;
  };

  const userStoriesText = feature.userStories?.length > 0
    ? feature.userStories.map(formatUserStory).join('\n')
    : 'No user stories defined';

  const content = `# ${feature.title}

## Description
${feature.description || 'No description provided'}

## User Stories
${userStoriesText}

## Technical Implementation
${typeof feature.technicalImplementation === 'string' 
  ? feature.technicalImplementation 
  : feature.technicalImplementation 
    ? JSON.stringify(feature.technicalImplementation, null, 2)
    : 'No technical details provided'}
`;

  try {
    await navigator.clipboard.writeText(content);
    return true;
  } catch (err) {
    console.error('Failed to copy:', err);
    return false;
  }
}

// Download generated code
export function downloadCode(feature: any) {
  const content = feature.generatedCode || '// Code not yet generated for this feature\n// Generate code in the Feature Builder panel';
  
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${feature.title.toLowerCase().replace(/\s+/g, '-')}.tsx`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// Export entire project as ZIP
export async function exportProjectAsZip(mindmap: any) {
  const zip = new JSZip();
  
  // Add README
  const readme = `# ${mindmap.title || mindmap.projectName}

${mindmap.description || mindmap.projectDescription || 'No description provided'}

## Generated by CodeLaunch

This export contains:

- **prds/**: Product Requirements Documents for each feature

- **code/**: Generated code for each feature (if available)

## How to Use

1. Open this folder in Cursor or your preferred IDE

2. Review the PRDs in the \`prds/\` folder

3. Use the code in \`code/\` as a starting point

4. Implement remaining features based on the PRDs

## Next Steps

- Set up your development environment

- Install dependencies: \`npm install\`

- Review each feature's PRD

- Start implementing!

---

Generated on ${new Date().toLocaleDateString()}
`;
  
  zip.file('README.md', readme);
  
  // Add PRDs folder
  const prdsFolder = zip.folder('prds');
  mindmap.features?.forEach((feature: any) => {
    // Format user stories - handle both string and object formats
    const formatUserStory = (story: any, i: number) => {
      if (typeof story === 'string') {
        return `${i + 1}. ${story}`;
      }
      if (story.persona && story.need && story.goal) {
        return `${i + 1}. As a ${story.persona}, I want to ${story.need} so that ${story.goal}`;
      }
      return `${i + 1}. ${JSON.stringify(story)}`;
    };

    const userStoriesText = feature.userStories?.length > 0
      ? feature.userStories.map(formatUserStory).join('\n')
      : 'No user stories defined';

    const content = `# ${feature.title}

## Description
${feature.description || 'No description provided'}

## User Stories
${userStoriesText}

## Acceptance Criteria
${feature.acceptanceCriteria?.map((criteria: string) => `- ${criteria}`).join('\n') || 'No acceptance criteria defined'}

## Technical Implementation
${typeof feature.technicalImplementation === 'string' 
  ? feature.technicalImplementation 
  : feature.technicalImplementation 
    ? JSON.stringify(feature.technicalImplementation, null, 2)
    : 'No technical details provided'}

## API Endpoints
${feature.apiEndpoints?.map((ep: any) => `- ${ep.method} ${ep.path} - ${ep.description}`).join('\n') || 'No API endpoints defined'}

## Dependencies
${feature.dependencies?.map((dep: string) => `- ${dep}`).join('\n') || 'No dependencies'}

## Priority
${feature.priority || 'Not set'}

## Estimated Effort
${feature.estimatedEffort || feature.estimatedHours ? `${feature.estimatedHours || feature.estimatedEffort} hours` : 'Not estimated'}

---
Generated by CodeLaunch
`;
    
    prdsFolder?.file(`${feature.title.toLowerCase().replace(/\s+/g, '-')}.md`, content);
  });
  
  // Add code folder (if features have generated code)
  const codeFolder = zip.folder('code');
  let hasCode = false;
  mindmap.features?.forEach((feature: any) => {
    if (feature.generatedCode) {
      hasCode = true;
      codeFolder?.file(
        `${feature.title.toLowerCase().replace(/\s+/g, '-')}.tsx`,
        feature.generatedCode
      );
    }
  });
  
  if (!hasCode) {
    codeFolder?.file(
      'README.md',
      '# Code\n\nNo code has been generated yet.\n\nUse the Feature Builder to generate code for each feature.'
    );
  }
  
  // Generate and download
  const blob = await zip.generateAsync({ type: 'blob' });
  saveAs(blob, `${(mindmap.title || mindmap.projectName || 'project').toLowerCase().replace(/\s+/g, '-')}-export.zip`);
}

